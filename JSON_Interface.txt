= NodeManager JSON Interface =

The JSON interface operates over a ZeroMQ REQ<->REP socket pair.


== General Notes ==
 - everything is a string except for response codes and the static field
 - response codes are based on HTTP
   - 200 : action ok with response data
   - 204 : action ok with no response data
   - 404 : unknown key or action
   - 406 : request is invalid
   - 409 : conflicting value
   - 500 : storing new value failed
   - 501 : unknown action


== Read All Configuration Values ==
=== Request ===
{{{
{
	"target":"openbts",
	"command":"config",
	"action":"read"
}
}}}
=== Response ===
{{{
{
	"code": 200,
	"data": [
		{
			"defaultValue": "/var/run/OpenBTS/command",
			"description": "Path for Unix domain datagram socket used for the OpenBTS console interface.",
			"key": "CLI.SocketPath",
			"static": false,
			"type": "file path",
			"units": "",
			"validValues": "",
			"value": "/var/run/OpenBTS/command",
			"visibility": "customer warn - a warning will be presented and confirmation required before changing this sensitive setting"
		},
		...
		{
			"defaultValue": "0",
			"description": "Location area code, 16 bits, values 0xFFxx are reserved.  For multi-BTS networks, assign a unique LAC to each BTS unit.  (That is not the normal procedure in conventional GSM networks, but is the correct procedure in OpenBTS networks.)",
			"key": "UMTS.Identity.LAC",
			"static": false,
			"type": "value range",
			"units": "",
			"validValues": "0:65280",
			"value": "0",
			"visibility": "customer warn - a warning will be presented and confirmation required before changing this sensitive setting"
		}
	]
}
}}}


== Read Configuration Value - Valid Key ==
=== Request ===
{{{
{
	"target":"openbts",
	"command":"config",
	"action":"read",
	"key":"GSM.Radio.Band"
}
}}}
=== Response ===
{{{
{
	"code": 200,
	"data": {
		"defaultValue": "900",
		"description": "The GSM operating band.  Valid values are 850 (GSM850), 900 (PGSM900), 1800 (DCS1800) and 1900 (PCS1900).  For non-multiband units, this value is dictated by the hardware and should not be changed.",
		"key": "GSM.Radio.Band",
		"static": true,
		"type": "multiple choice",
		"units": "",
		"validValues": "850|GSM850,900|PGSM900,1800|DCS1800,1900|PCS1900",
		"value": "850",
		"visibility": "factory - set once at the factory, should never be changed"
	}
}
}}}


== Read Configuration Value - Invalid Key ==
=== Request ===
{{{
{
	"target":"openbts",
	"command":"config",
	"action":"read",
	"key":"THISKEYISINVALID"
}
}}}
=== Response ===
{{{
{
	"code":404
}
}}}


== Update Configuration Value - Valid Key and Valid Value ==
=== Request ===
{{{
{
	"target":"openbts",
	"command":"config",
	"action":"update",
	"key":"GSM.Radio.C0",
	"value":"151"
}
}}}
=== Response ===
{{{
{
	"code":204
}
}}}


== Update Configuration Value - Invalid Key and Valid Value ==
=== Request ===
{{{
{
	"target":"openbts",
	"command":"config",
	"action":"update",
	"key":"THISKEYISINVALID",
	"value":"151"
}
}}}
=== Response ===
{{{
{
	"code":404
}
}}}


== Update Configuration Value - Valid Key and Invalid Value ==
=== Request ===
{{{
{
	"target":"openbts",
	"command":"config",
	"action":"update",
	"key":"GSM.Radio.C0",
	"value":"999"
}
}}}
=== Response ===
{{{
{
	"code":406
}
}}}


== Read Version ==
=== Request ===
{{{
{
	"target":"openbts",
	"command":"version",
	"action":"read"
}
}}}
=== Response ===
{{{
{
	"code":200,
	"data":"release 3.0TRUNK C built Feb 28 2013 rev4981M"
}
}}}


== Start a Timed PCAP Trace ==
=== Request ===
{{{
{
	"target":"openbts",
	"command":"trace",
	"action":"start",
	"filename":"/tmp/mytrace.pcap",
	"interface":"any",
	"filter":"udp port 5060",
	"seconds":"10"
}
}}}
=== Response ===
{{{
{
	"code":204
}
}}}


== Conflicts Between Multiple Key/Value Pairs ==

Right now, the JSON interface will only examine the key/value pair by itself. Its potential conflict with other values is not taken into consideration. This kind of check is really only ever needed for conflicts between GSM.Radio.Band and GSM.Radio.C0. These two values must be changed in tandem sometimes. All other relationships between multiple key/value pairs are only interesting to optimize or guarantee that the desired behavior is achieved. A C++ implementation of these "crossChecks" follows. This is taken directly from the bottom of OpenBTS.cpp.

/** Return warning strings about a potential conflicting value */
vector<string> configurationCrossCheck(const string& key) {
	vector<string> warnings;
	ostringstream warning;

	// GSM.Timer.T3113 should equal SIP.Timer.B
	if (key.compare("GSM.Timer.T3113") == 0 || key.compare("SIP.Timer.B") == 0) {
		string gsm = gConfig.getStr("GSM.Timer.T3113");
		string sip = gConfig.getStr("SIP.Timer.B");
		if (gsm.compare(sip) != 0) {
			warning << "GSM.Timer.T3113 (" << gsm << ") and SIP.Timer.B (" << sip << ") should usually have the same value";
			warnings.push_back(warning.str());
			warning.str(std::string());
		}

	// Control.VEA depends on GSM.CellSelection.NECI
	} else if (key.compare("Control.VEA") == 0 || key.compare("GSM.CellSelection.NECI") == 0) {
		if (gConfig.getBool("Control.VEA") && gConfig.getStr("GSM.CellSelection.NECI").compare("1") != 0) {
			warning << "Control.VEA is enabled but will not be functional until GSM.CellSelection.NECI is set to \"1\"";
			warnings.push_back(warning.str());
			warning.str(std::string());
		}

	// GSM.Timer.T3212 should be a factor of six and shorter than SIP.RegistrationPeriod
	} else if (key.compare("GSM.Timer.T3212") == 0 || key.compare("SIP.RegistrationPeriod") == 0) {
		int gsm = gConfig.getNum("GSM.Timer.T3212");
		int sip = gConfig.getNum("SIP.RegistrationPeriod");
		if (key.compare("GSM.Timer.T3212") == 0 && gsm % 6) {
			warning << "GSM.Timer.T3212 should be a factor of 6";
			warnings.push_back(warning.str());
			warning.str(std::string());
		}
		if (gsm >= sip) {
			warning << "GSM.Timer.T3212 (" << gsm << ") should be shorter than SIP.RegistrationPeriod (" << sip << ")";
			warnings.push_back(warning.str());
			warning.str(std::string());
		}

	// GPRS.ChannelCodingControl.RSSI should normally be 10db more than GSM.Radio.RSSITarget
	} else if (key.compare("GPRS.ChannelCodingControl.RSSI") == 0 || key.compare("GSM.Radio.RSSITarget") == 0) {
		int gprs = gConfig.getNum("GPRS.ChannelCodingControl.RSSI");
		int gsm = gConfig.getNum("GSM.Radio.RSSITarget");
		if ((gprs - gsm) != 10) {
			warning << "GPRS.ChannelCodingControl.RSSI (" << gprs << ") should normally be 10db higher than GSM.Radio.RSSITarget (" << gsm << ")";
			warnings.push_back(warning.str());
			warning.str(std::string());
		}

	// TODO : This NEEDS to be an error not a warning. OpenBTS will fail to start because of an assert if an invalid value is used.
	// GSM.Radio.C0 needs to be inside the valid range of ARFCNs for GSM.Radio.Band
	} else if (key.compare("GSM.Radio.C0") == 0 || key.compare("GSM.Radio.Band") == 0) {
		int c0 = gConfig.getNum("GSM.Radio.C0");
		string band = gConfig.getStr("GSM.Radio.Band");
		string range;
		if (band.compare("850") == 0 && (c0 < 128 || 251 < c0)) {
			range = "128-251";
		} else if (band.compare("900") == 0 && (c0 < 1 || 124 < c0)) {
			range = "1-124";
		} else if (band.compare("1800") == 0 && (c0 < 512 || 885 < c0)) {
			range = "512-885";
		} else if (band.compare("1900") == 0 && (c0 < 512 || 810 < c0)) {
			range = "512-810";
		}
		if (range.length()) {
			warning << "GSM.Radio.C0 (" << c0 << ") falls outside the valid range of ARFCNs " << range << " for GSM.Radio.Band (" << band << ")";
			warnings.push_back(warning.str());
			warning.str(std::string());
		}

	// SGSN.Timer.ImplicitDetach should be at least 240 seconds greater than SGSN.Timer.RAUpdate"
	} else if (key.compare("SGSN.Timer.ImplicitDetach") == 0 || key.compare("SGSN.Timer.RAUpdate") == 0) {
		int detach = gConfig.getNum("SGSN.Timer.ImplicitDetach");
		int update = gConfig.getNum("SGSN.Timer.RAUpdate");
		if ((detach - update) < 240) {
			warning << "SGSN.Timer.ImplicitDetach (" << detach << ") should be at least 240 seconds greater than SGSN.Timer.RAUpdate (" << update << ")";
			warnings.push_back(warning.str());
			warning.str(std::string());
		}

	// Control.LUR.WhiteList depends on Control.WhiteListing.Message, Control.LUR.WhiteListing.RejectCause and Control.WhiteListing.ShortCode
	} else if (key.compare("Control.LUR.WhiteList") == 0 || key.compare("Control.WhiteListing.Message") == 0 ||
				key.compare("Control.LUR.WhiteListing.RejectCause") == 0 || key.compare("Control.WhiteListing.ShortCode") == 0) {
		if (gConfig.getBool("Control.LUR.WhiteList")) {
			if (!gConfig.getStr("Control.WhiteListing.Message").length()) {
				warning << "Control.LUR.WhiteList is enabled but will not be functional until Control.WhiteListing.Message is set";
				warnings.push_back(warning.str());
				warning.str(std::string());
			} else if (!gConfig.getStr("Control.LUR.WhiteListing.RejectCause").length()) {
				warning << "Control.LUR.WhiteList is enabled but will not be functional until Control.WhiteListing.RejectCause is set";
				warnings.push_back(warning.str());
				warning.str(std::string());
			} else if (!gConfig.getStr("Control.WhiteListing.ShortCode").length()) {
				warning << "Control.LUR.WhiteList is enabled but will not be functional until Control.WhiteListing.ShortCode is set";
				warnings.push_back(warning.str());
				warning.str(std::string());
			}
		}

	// GSM.CellSelection.NCCsPermitted needs to contain our own GSM.Identity.BSIC.NCC
	} else if (key.compare("GSM.CellSelection.NCCsPermitted") == 0 || key.compare("GSM.Identity.BSIC.NCC") == 0) {
		int ourNCCMask = gConfig.getNum("GSM.CellSelection.NCCsPermitted");
		int NCCMaskBit = 1 << gConfig.getNum("GSM.Identity.BSIC.NCC");
		if ((NCCMaskBit & ourNCCMask) == 0) {
			warning << "GSM.CellSelection.NCCsPermitted is not set to a mask which contains the local network color code defined in GSM.Identity.BSIC.NCC. ";
			warning << "Set GSM.CellSelection.NCCsPermitted to " << NCCMaskBit;
			warnings.push_back(warning.str());
			warning.str(std::string());
		}

	// Control.LUR.FailedRegistration.Message depends on Control.LUR.FailedRegistration.ShortCode
	} else if (key.compare("Control.LUR.FailedRegistration.Message") == 0 || key.compare("Control.LUR.FailedRegistration.ShortCode") == 0) {
		if (gConfig.getStr("Control.LUR.FailedRegistration.Message").length() && !gConfig.getStr("Control.LUR.FailedRegistration.ShortCode").length()) {
			warning << "Control.LUR.FailedRegistration.Message is enabled but will not be functional until Control.LUR.FailedRegistration.ShortCode is set";
			warnings.push_back(warning.str());
			warning.str(std::string());
		}

	// Control.LUR.NormalRegistration.Message depends on Control.LUR.NormalRegistration.ShortCode
	} else if (key.compare("Control.LUR.NormalRegistration.Message") == 0 || key.compare("Control.LUR.NormalRegistration.ShortCode") == 0) {
		if (gConfig.getStr("Control.LUR.NormalRegistration.Message").length() && !gConfig.getStr("Control.LUR.NormalRegistration.ShortCode").length()) {
			warning << "Control.LUR.NormalRegistration.Message is enabled but will not be functional until Control.LUR.NormalRegistration.ShortCode is set";
			warnings.push_back(warning.str());
			warning.str(std::string());
		}

	// Control.LUR.OpenRegistration depends on Control.LUR.OpenRegistration.ShortCode
	} else if (key.compare("Control.LUR.OpenRegistration") == 0 || key.compare("Control.LUR.OpenRegistration.ShortCode") == 0) {
		if (gConfig.getStr("Control.LUR.OpenRegistration").length() && !gConfig.getStr("Control.LUR.OpenRegistration.ShortCode").length()) {
			warning << "Control.LUR.OpenRegistration is enabled but will not be functional until Control.LUR.OpenRegistration.ShortCode is set";
			warnings.push_back(warning.str());
			warning.str(std::string());
		}

	// TODO : SIP.SMSC is actually broken with the verification bits, no way to set value as null
	// SIP.SMSC should normally be NULL if SMS.MIMIEType is "text/plain" and "smsc" if SMS.MIMEType is "application/vnd.3gpp".
	} else if (key.compare("SMS.MIMEType") == 0 || key.compare("SIP.SMSC") == 0) {
		string sms = gConfig.getStr("SMS.MIMEType");
		string sip = gConfig.getStr("SIP.SMSC");
		if (sms.compare("application/vnd.3gpp.sms") == 0 && sip.compare("smsc") != 0) {
			warning << "SMS.MIMEType is set to \"application/vnc.3gpp.sms\", SIP.SMSC should usually be set to \"smsc\"";
			warnings.push_back(warning.str());
			warning.str(std::string());
		}

	// Control.Emergency.Geolocation depends on Control.Emergency.GatewaySwitch
	} else if (key.compare("Control.Emergency.Geolocation") == 0 || key.compare("Control.Emergency.GatewaySwitch") == 0) {
		if (gConfig.getStr("Control.Emergency.Geolocation").length() && !gConfig.getStr("Control.Emergency.GatewaySwitch").length()) {
			warning << "Control.Emergency.Geolocation is enabled but will not be functional until Control.Emergency.GatewaySwitch is set";
			warnings.push_back(warning.str());
			warning.str(std::string());
		}

#if GPRS_ENABLE==1
	// Warn if a user is trying to use GPRS with an incompatible binary
	} else if (key.compare("GPRS.Enable") == 0) {
		if (gConfig.getBool("GPRS.Enable")) {
			warning << "GPRS.Enable is actived but you are not using a GPRS capable version of OpenBTS. ";
			warning << "Please contact sales@rangenetworks.com to purchase an upgrade (or set GPRS.Enable to 0 to get rid of this warning.)";
			warnings.push_back(warning.str());
			warning.str(std::string());
		}
#endif
	}
}